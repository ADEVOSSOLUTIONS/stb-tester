#!/usr/bin/env bash
#                                                    -*- sh-basic-offset: 2 -*-

# Copyright 2013 YouView TV Ltd.
# License: LGPL v2.1 or (at your option) any later version (see
# https://github.com/stb-tester/stb-tester/blob/master/LICENSE for details).

#/ Usage:
#/   stbt batch run [options] test.py [test.py ...]
#/   stbt batch run [options] test.py arg [arg ...] -- test.py arg [arg ...] [-- ...]
#/
#/ Options:
#/   -1    Run once. The default behaviour is to run the test
#/         repeatedly as long as it passes.
#/   -k    Continue running after "uninteresting" failures.
#/   -kk   Continue running after any failure (except those
#/         that would prevent any further test from passing).
#/
#/   -d    Enable "stbt-debug" dump of intermediate images.
#/   -v    Verbose. Print stbt standard output.
#/   -vv   Extra verbose. Print stbt standard error output.
#/
#/   -o    Output directory to save the report and test-run
#/         logs under (defaults to the current directory).
#/   -t <tag>  Tag to add to test run directory names (useful
#/         to differentiate directories when you intend to
#/         merge test results from multiple machines).

usage() { grep '^#/' "$0" | cut -c4-; }
die() { echo "$(basename "$0"): error: $*" >&2; exit 1; }

main() {
  runner=$(dirname "$(realpath "$0")")
  export PYTHONUNBUFFERED=x

  keep_going=0
  outputdir="$PWD"
  run_once=false
  stop=false
  tag=
  v=-v
  verbose=0
  failure_count=0
  while getopts ":1dhko:t:v" option; do
    case $option in
      1) run_once=true;;
      d) v=-vv;;
      h) usage; exit 0;;
      k) keep_going=$((keep_going + 1));;
      o) outputdir=$(realpath "$OPTARG");;
      t) tag=-$OPTARG;;
      v) verbose=$((verbose + 1));;
      *) die "Invalid option '-$OPTARG'. Use '-h' for help.";;
    esac
  done
  shift $((OPTIND - 1))
  [[ $# -gt 0 ]] || { usage >&2; exit 1; }

  which ts &>/dev/null ||
    die "No 'ts' command found; please install 'moreutils' package"

  run_count=0
  while true; do
    while IFS=$'\t' read -a test; do
      run_count=$((run_count+1))
      run "${test[@]}" </dev/null;
      last_exit_status=$?
      [ "$last_exit_status" = 0 ] || failure_count=$((failure_count+1))
      if [ -e "$outputdir/latest$tag/unrecoverable-error" ]; then
        stop=true
      fi
      should_i_continue || break 2
    done < <(parse_test_args "$@")
    $run_once && break
  done

  if [ "$run_count" = 1 ]; then
    # If we only run a single test a single time propagate the result through
    exit "$last_exit_status"
  elif [ "$failure_count" = 0 ]; then
    exit 0
  else
    exit 1
  fi
}

trap on_kill1 sigint sigterm
on_kill1() {
  printf "\nReceived interrupt; waiting for current test to complete.\n" >&2
  stop=true
  trap on_kill2 sigint sigterm
}
on_kill2() {
  echo "Received interrupt; exiting." >&2
}

should_i_continue() {
  $stop && return 1;
  [[ $exit_status -eq 0 ]] ||
  # "Uninteresting" failures due to the test infrastructure
  [[ $keep_going -gt 0 && $exit_status -gt 1 ]] ||
  # Failures due to the system under test
  [[ $keep_going -gt 1 ]]
}

# Input:
#   test1.py arg1 arg2 -- test2.py arg -- test3.py
# Output (suitable as input to `IFS=$'\t' read -a`):
#   test1.py\targ1\targ2
#   test2.py\targ
#   test3.py
parse_test_args() {
  if [[ "$*" =~ -- ]]; then
    [[ "$1" == -- ]] && shift
    while [[ $# -gt 0 ]]; do
      printf "%s" "$1"; shift
      while [[ $# -gt 0 && "$1" != -- ]]; do printf "\t%s" "$1"; shift; done
      printf "\n"
      [[ "$1" == -- ]] && shift
    done
  else  # No "--": Each command-line argument is a test script.
    printf "%s\n" "$@"
  fi
}

# Portable implementation of GNU "readlink -f" to support BSD/OSX.
realpath() {
  python -c 'import os, sys; print os.path.realpath(sys.argv[1])' "$1"
}

main "$@"
