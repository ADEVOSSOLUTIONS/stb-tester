#!/usr/bin/env bash
#                                                    -*- sh-basic-offset: 2 -*-

#/ Usage: report <testrun directory> [<testrun directory>...]
#/
#/ Classifies the results previously generated by 'run'
#/ according to the reason for failure.
#/ The class of failure is printed to stdout and to the
#/ file <testrun directory>/failure-reason.

usage() { grep '^#/' "$0" | cut -c4-; }

main() {
  runner=$(dirname "$(abspath "$0")")

  while getopts "h" option; do
    case $option in
      h) usage; exit 0;;
      *) die "Invalid option '-$option'. Use '-h' for help.";;
    esac
  done
  shift $((OPTIND - 1))
  [[ $# -gt 0 ]] || { usage >&2; exit 1; }

  for rundir in "$@"; do
    (
      cd "$rundir" || die "Invalid directory '$rundir'"
      [ -r exit-status ] ||
        die "No exit status (test still in progress); skipping"
      classify
      sort --merge stdout.log stderr.log > combined.log
      grep -q "Didn't find match" failure-reason && template
      [ -f core* ] && backtrace core*
      python "$runner"/report.py . > index.html.$$ && mv index.html.$$ index.html
    )
  done

  # Generate summary report
  for resultsdir in $(
    for rundir in "$@"; do dirname $(abspath $rundir); done | sort | uniq)
  do
    (
      cd "$resultsdir" || die "Invalid directory '$resultsdir'"
      python "$runner"/report.py index.html > index.html.$$ &&
      mv index.html.$$ index.html
    )
  done
}

classify() {
  local status=$(cat exit-status)
  local testname=$(cat test-name)

  if [ $status -eq 0 ]; then
    reason success

  elif [ $status -gt 128 ]; then
    reason killed "($(signalname $((status - 128))))"

  elif grep -q "FAIL: .*$(basename "$testname"): " stdout.log; then
    reason "$(sed -n "s/^.*FAIL: .*$(basename "$testname"): //p" stdout.log)"

  else
    reason unknown
  fi
}

reason() {
  echo "$*" > failure-reason
  debug "$*"
}

signalname() {
  local num=$1
  ( set -o pipefail
    kill -l | grep -Eo "\b$num\) SIG\S+" | awk '{print tolower($2)}' ||
      echo $num
  )
}

template() {
  [ -f template.png ] && return  # Don't overwrite if `report` is re-run later
  local template=$(
    sed -n 's,^.*stbt-run: Searching for \(.*\.png\)$,\1,p' stderr.log |
    tail -1)
  [ -f "$template" ] && cp "$template" template.png
}

backtrace() {
  [ -f backtrace.log ] && return  # Don't overwrite if `report` is re-run later
  local gdbcommand corefile=$1
  gdbcommand=$(mktemp -t report.XXX) || die "Failed to create temp file"
  echo "thread apply all bt" > $gdbcommand
  gdb $(which python) $corefile -batch -x $gdbcommand &> backtrace.log
  rm -f $gdbcommand
}

debug() { echo "$rundir: $*"; }
die() { echo "$(basename "$0"): error: $*" >&2; exit 1; }

# Portable implementation of GNU "readlink -f" to support BSD/OSX.
abspath() {
  python -c 'import os, sys; print os.path.realpath(sys.argv[1])' "$1"
}

main "$@"
